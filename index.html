<!doctype html>
<meta charset="utf-8" />
<title>WASD Runner (Web)</title>
<style>
  :root { color-scheme: dark; }
  body { margin: 0; background:#111; color:#eee; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  pre  { line-height: 1.1; font-size: 16px; padding: 12px; outline: none; }
</style>
<pre id="screen" tabindex="0"></pre>
<script>
(() => {
  // ====== 닉네임 & 스코어 저장 ======
  const NICK_KEY   = 'game_test_nick';
  const SCORE_KEY  = 'game_test_best';
  function getNick() {
    let n = localStorage.getItem(NICK_KEY);
    if (!n) {
      n = prompt('닉네임을 입력하세요(최대 16자):') || 'Player';
      n = String(n).slice(0, 16);
      try { localStorage.setItem(NICK_KEY, n); } catch {}
    }
    return n;
  }
  function saveBest(name, score) {
    const key = `${SCORE_KEY}:${name}`;
    let best = 0;
    try { best = parseInt(localStorage.getItem(key) || '0', 10); } catch {}
    if (score > best) {
      best = score;
      try { localStorage.setItem(key, String(best)); } catch {}
    }
    return best;
  }
  function loadBest(name) {
    const key = `${SCORE_KEY}:${name}`;
    let best = 0;
    try { best = parseInt(localStorage.getItem(key) || '0', 10); } catch {}
    return best;
  }

  function getTopScores() {
    const scores = [];
    try {
      for (let key in localStorage) {
        if (key.startsWith(SCORE_KEY + ':')) {
          const name = key.substring((SCORE_KEY + ':').length);
          const score = parseInt(localStorage.getItem(key) || '0', 10);
          scores.push([name, score]);
        }
      }
    } catch {}
    scores.sort((a, b) => b[1] - a[1]);
    return scores.slice(0, 10);
  }

  // ====== 게임 상태 ======
  const W = 30, H = 12;
  let px, py, lives, score, running, hitCooldown;
  const TICK_MS = 70;
  const HIT_IFRAME_MS = 800;
  let enemies = [], coins = [];
  const screen = document.getElementById('screen');
  const rnd = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const isBorder = (x,y) => (x===0 || y===0 || x===W-1 || y===H-1);
  const nick = getNick();
  let gameLoopId = null;
  let lastEnemySpawnScore = 0;
  let enemyMoveCounter = 0;

  function resetGame() {
    px = Math.floor(W/2); 
    py = Math.floor(H/2);
    lives = 3; 
    score = 0; 
    running = true;
    hitCooldown = 0;
    enemies.length = 0; 
    coins.length = 0;
    lastEnemySpawnScore = 0;
    enemyMoveCounter = 0;
    spawnInitial();
  }

  // ====== 스폰 ======
  function spawnInitial() {
    for (let i=0;i<3;i++){
      let ex=rnd(1,W-2), ey=rnd(1,H-2);
      if (ex===px && ey===py) { i--; continue; }
      enemies.push([ex,ey]);
    }
    for (let i=0;i<5;i++){
      let cx=rnd(1,W-2), cy=rnd(1,H-2);
      if (cx===px && cy===py) { i--; continue; }
      coins.push([cx,cy]);
    }
  }

  // ====== 렌더 ======
  function draw(extraLines=[]) {
    const buf = [];
    const livesView = Math.max(0, lives);
    const invText   = hitCooldown > 0 ? " (무적)" : "";
    buf.push(`WASD/Arrow 이동, Q:종료, R:재시작 | o:코인 E:적  #:벽`);
    buf.push(`Player: ${nick}  Lives: ${livesView}${invText}  Score: ${score}  Best: ${loadBest(nick)}`);

    for (let y=0;y<H;y++) {
      let row = "";
      for (let x=0;x<W;x++) row += isBorder(x,y) ? "#" : " ";
      buf.push(row);
    }
    const put = (x,y,ch) => {
      const i = y+2;
      const line = buf[i];
      buf[i] = line.slice(0,x) + ch + line.slice(x+1);
    };
    for (const [cx,cy] of coins)   put(cx,cy,'o');
    for (const [ex,ey] of enemies) put(ex,ey,'E');
    put(px,py,'@');

    for (const line of extraLines) buf.push(line);
    screen.textContent = buf.join("\n");
  }

  // ====== 로직 ======
  function movePlayerBy(dx,dy) {
    const nx = px + dx, ny = py + dy;
    if (isBorder(nx,ny)) {
      if (hitCooldown <= 0 && lives > 0) {
        lives = Math.max(0, lives - 1);
        px = Math.floor(W/2); 
        py = Math.floor(H/2);
        hitCooldown = HIT_IFRAME_MS;
        if (lives === 0) {
          running = false;
        }
      }
      draw();
      return;
    }
    px = nx; 
    py = ny;
    collide();
    draw();
  }

  function moveEnemies() {
    if (score < 60) return;
    
    let moveInterval = 5;
    if (score >= 100) moveInterval = 4;
    if (score >= 200) moveInterval = 3;
    if (score >= 300) moveInterval = 2;
    
    enemyMoveCounter++;
    if (enemyMoveCounter % moveInterval !== 0) return;
    
    for (let i = 0; i < enemies.length; i++) {
      const [ex, ey] = enemies[i];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const [dx,dy] = dirs[rnd(0,3)];
      
      const nx = ex+dx, ny = ey+dy;
      if (!isBorder(nx,ny)) {
        enemies[i] = [nx, ny];
      }
    }
  }

  function collide() {
    for (let i=0;i<coins.length; ) {
      if (coins[i][0] === px && coins[i][1] === py) {
        score += 10;
        coins.splice(i,1);
        let attempts = 0;
        let cx, cy;
        do {
          cx = rnd(1,W-2);
          cy = rnd(1,H-2);
          attempts++;
        } while (((cx === px && cy === py) || 
                 enemies.some(([ex,ey]) => ex === cx && ey === cy) ||
                 coins.some(([cx2,cy2]) => cx2 === cx && cy2 === cy)) &&
                 attempts < 50);
        coins.push([cx,cy]);
      } else { 
        i++; 
      }
    }
    
    const hit = enemies.some(([ex,ey]) => ex === px && ey === py);
    if (hit && hitCooldown <= 0 && lives > 0) {
      lives = Math.max(0, lives - 1);
      px = Math.floor(W/2); 
      py = Math.floor(H/2);
      hitCooldown = HIT_IFRAME_MS;
      if (lives === 0) {
        running = false;
      }
    }
  }

  // ====== 메인 루프 ======
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;
    let acc = (window.gameAcc || 0) + dt;

    hitCooldown = Math.max(0, hitCooldown - dt);

    if (!running || lives <= 0) {
      hitCooldown = 0;
      const best = saveBest(nick, score);
      const topScores = getTopScores();
      const lines = [
        "",
        "===== GAME OVER =====",
        `최종 점수: ${score}   최고 점수(${nick}): ${best}`,
        ""
      ];
      
      if (topScores.length > 0) {
        lines.push("===== TOP 10 =====");
        topScores.forEach((item, idx) => {
          lines.push(`${idx + 1}. ${item[0]}: ${item[1]}`);
        });
        lines.push("");
      }
      
      lines.push("R: 재시작, Q: 종료");
      draw(lines);
      return;
    }

    while (acc >= TICK_MS && running && lives > 0) {
      moveEnemies();
      collide();
      if (score >= 100 && score > lastEnemySpawnScore && (score - lastEnemySpawnScore) % 100 === 0 && rnd(1,100) <= 25) {
        enemies.push([rnd(1,W-2), rnd(1,H-2)]);
        lastEnemySpawnScore = score;
      }
      acc -= TICK_MS;
    }

    window.gameAcc = acc;
    draw();
    gameLoopId = requestAnimationFrame(loop);
  }

  // ====== 입력 ======
  window.addEventListener('keydown', (e) => {
    const c = e.code;
    if (c === 'KeyQ') { 
      running = false; 
      return; 
    }
    if (c === 'KeyR') { 
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      resetGame();
      window.gameAcc = 0;
      last = performance.now();
      draw();
      gameLoopId = requestAnimationFrame(loop);
      return; 
    }
    if (!running || lives <= 0) return;

    if (c === 'KeyW' || c === 'ArrowUp')    movePlayerBy(0,-1);
    else if (c === 'KeyS' || c === 'ArrowDown') movePlayerBy(0, 1);
    else if (c === 'KeyA' || c === 'ArrowLeft') movePlayerBy(-1,0);
    else if (c === 'KeyD' || c === 'ArrowRight')movePlayerBy( 1,0);
  });

  screen.addEventListener('click', () => screen.focus());
  screen.focus();

  // ====== 시작 ======
  resetGame();
  draw();
  gameLoopId = requestAnimationFrame(loop);
})();
</script>