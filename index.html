<!doctype html>
<meta charset="utf-8" />
<title>WASD Runner (Web)</title>
<style>
  :root { color-scheme: dark; }
  body { margin: 0; background:#111; color:#eee; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  pre  { line-height: 1.1; font-size: 16px; padding: 12px; outline: none; }
</style>
<pre id="screen" tabindex="0"></pre>
<script src="./config.js"></script>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAnalytics, isSupported as analyticsIsSupported } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-analytics.js";
import { getFirestore, collection, addDoc, serverTimestamp, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

(() => {
  // ====== Firebase 설정 ======
  const providedConfig = window.WASD_RUNNER_FIREBASE_CONFIG || null;
  const firebaseConfig = providedConfig || {
    apiKey: 'YOUR_FIREBASE_API_KEY',
    authDomain: 'YOUR_FIREBASE_AUTH_DOMAIN',
    projectId: 'YOUR_FIREBASE_PROJECT_ID',
    storageBucket: 'YOUR_FIREBASE_STORAGE_BUCKET',
    messagingSenderId: 'YOUR_FIREBASE_SENDER_ID',
    appId: 'YOUR_FIREBASE_APP_ID',
    measurementId: 'YOUR_FIREBASE_MEASUREMENT_ID'
  };

  let firebaseApp = null;
  let firestoreDb = null;
  let firebaseAnalytics = null;
  let firebaseEnabled = false;

  function initFirebase() {
    if (!providedConfig) {
      const placeholderValues = Object.values(firebaseConfig).some((value) =>
        typeof value === 'string' && value.startsWith('YOUR_FIREBASE_')
      );
      if (placeholderValues) {
        console.warn('Firebase config is using placeholder values. Online leaderboard disabled.');
        return;
      }
    }
    try {
      firebaseApp = initializeApp(firebaseConfig);
      firestoreDb = getFirestore(firebaseApp);
      firebaseEnabled = true;
      analyticsIsSupported().then((supported) => {
        if (supported) {
          firebaseAnalytics = getAnalytics(firebaseApp);
        }
      }).catch((err) => console.warn('Firebase analytics unsupported:', err));
      console.info('Firebase initialized successfully.');
    } catch (err) {
      console.warn('Failed to initialize Firebase:', err);
    }
  }

  initFirebase();

  async function submitOnlineScore(name, score) {
    if (!firebaseEnabled || !firestoreDb) return Promise.resolve();
    if (typeof score !== 'number' || score <= 0) return Promise.resolve();
    const safeName = String(name || 'Player').slice(0, 32);
    try {
      await addDoc(collection(firestoreDb, 'leaderboard'), {
        name: safeName,
        score,
        createdAt: serverTimestamp()
      });
    } catch (err) {
      console.warn('Failed to submit score to leaderboard:', err);
      throw err;
    }
  }

  async function fetchOnlineLeaderboard(limitCount = 10) {
    if (!firebaseEnabled || !firestoreDb) return [];
    try {
      const snapshot = await getDocs(
        query(
          collection(firestoreDb, 'leaderboard'),
          orderBy('score', 'desc'),
          limit(limitCount)
        )
      );
      return snapshot.docs
        .map((doc) => doc.data())
        .filter((entry) => entry && typeof entry.score === 'number');
    } catch (err) {
      console.warn('Failed to fetch leaderboard:', err);
      throw err;
    }
  }

  // ====== 닉네임 & 스코어 저장 ======
  const NICK_KEY   = 'game_test_nick';
  const SCORE_KEY  = 'game_test_best';
  function getNick() {
    let n = localStorage.getItem(NICK_KEY);
    if (!n) {
      n = prompt('닉네임을 입력하세요(최대 16자):') || 'Player';
      n = String(n).slice(0, 16);
      try { localStorage.setItem(NICK_KEY, n); } catch {}
    }
    return n;
  }
  function saveBest(name, score) {
    const key = `${SCORE_KEY}:${name}`;
    let best = 0;
    try { best = parseInt(localStorage.getItem(key) || '0', 10); } catch {}
    if (score > best) {
      best = score;
      try { localStorage.setItem(key, String(best)); } catch {}
    }
    return best;
  }
  function loadBest(name) {
    const key = `${SCORE_KEY}:${name}`;
    let best = 0;
    try { best = parseInt(localStorage.getItem(key) || '0', 10); } catch {}
    return best;
  }

  function getTopScores() {
    const scores = [];
    try {
      for (let key in localStorage) {
        if (key.startsWith(SCORE_KEY + ':')) {
          const name = key.substring((SCORE_KEY + ':').length);
          const score = parseInt(localStorage.getItem(key) || '0', 10);
          scores.push([name, score]);
        }
      }
    } catch {}
    scores.sort((a, b) => b[1] - a[1]);
    return scores.slice(0, 10);
  }

  // ====== 게임 상태 ======
  const W = 30, H = 12;
  let px, py, lives, score, running, hitCooldown;
  const TICK_MS = 70;
  const HIT_IFRAME_MS = 800;
  let enemies = [], coins = [];
  const screen = document.getElementById('screen');
  const rnd = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const isBorder = (x,y) => (x===0 || y===0 || x===W-1 || y===H-1);
  const nick = getNick();
  let gameLoopId = null;
  let lastEnemySpawnScore = 0;
  let enemyMoveCounter = 0;

  function resetGame() {
    px = Math.floor(W/2); 
    py = Math.floor(H/2);
    lives = 3; 
    score = 0; 
    running = true;
    hitCooldown = 0;
    enemies.length = 0; 
    coins.length = 0;
    lastEnemySpawnScore = 0;
    enemyMoveCounter = 0;
    spawnInitial();
  }

  // ====== 스폰 ======
  function spawnInitial() {
    for (let i=0;i<3;i++){
      let ex=rnd(1,W-2), ey=rnd(1,H-2);
      if (ex===px && ey===py) { i--; continue; }
      enemies.push([ex,ey]);
    }
    for (let i=0;i<5;i++){
      let cx=rnd(1,W-2), cy=rnd(1,H-2);
      if (cx===px && cy===py) { i--; continue; }
      coins.push([cx,cy]);
    }
  }

  // ====== 렌더 ======
  function draw(extraLines=[]) {
    const buf = [];
    const livesView = Math.max(0, lives);
    const invText   = hitCooldown > 0 ? " (무적)" : "";
    buf.push(`WASD/Arrow 이동, Q:종료, R:재시작 | o:코인 E:적  #:벽`);
    buf.push(`Player: ${nick}  Lives: ${livesView}${invText}  Score: ${score}  Best: ${loadBest(nick)}`);

    for (let y=0;y<H;y++) {
      let row = "";
      for (let x=0;x<W;x++) row += isBorder(x,y) ? "#" : " ";
      buf.push(row);
    }
    const put = (x,y,ch) => {
      const i = y+2;
      const line = buf[i];
      buf[i] = line.slice(0,x) + ch + line.slice(x+1);
    };
    for (const [cx,cy] of coins)   put(cx,cy,'o');
    for (const [ex,ey] of enemies) put(ex,ey,'E');
    put(px,py,'@');

    for (const line of extraLines) buf.push(line);
    screen.textContent = buf.join("\n");
  }

  // ====== 로직 ======
  function movePlayerBy(dx,dy) {
    const nx = px + dx, ny = py + dy;
    if (isBorder(nx,ny)) {
      if (hitCooldown <= 0 && lives > 0) {
        lives = Math.max(0, lives - 1);
        px = Math.floor(W/2); 
        py = Math.floor(H/2);
        hitCooldown = HIT_IFRAME_MS;
        if (lives === 0) {
          running = false;
        }
      }
      draw();
      return;
    }
    px = nx; 
    py = ny;
    collide();
    draw();
  }

  function moveEnemies() {
    if (score < 60) return;
    
    let moveInterval = 5;
    if (score >= 100) moveInterval = 4;
    if (score >= 200) moveInterval = 3;
    if (score >= 300) moveInterval = 2;
    
    enemyMoveCounter++;
    if (enemyMoveCounter % moveInterval !== 0) return;
    
    for (let i = 0; i < enemies.length; i++) {
      const [ex, ey] = enemies[i];
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const [dx,dy] = dirs[rnd(0,3)];
      
      const nx = ex+dx, ny = ey+dy;
      if (!isBorder(nx,ny)) {
        enemies[i] = [nx, ny];
      }
    }
  }

  function collide() {
    for (let i=0;i<coins.length; ) {
      if (coins[i][0] === px && coins[i][1] === py) {
        score += 10;
        coins.splice(i,1);
        let attempts = 0;
        let cx, cy;
        do {
          cx = rnd(1,W-2);
          cy = rnd(1,H-2);
          attempts++;
        } while (((cx === px && cy === py) || 
                 enemies.some(([ex,ey]) => ex === cx && ey === cy) ||
                 coins.some(([cx2,cy2]) => cx2 === cx && cy2 === cy)) &&
                 attempts < 50);
        coins.push([cx,cy]);
      } else { 
        i++; 
      }
    }
    
    const hit = enemies.some(([ex,ey]) => ex === px && ey === py);
    if (hit && hitCooldown <= 0 && lives > 0) {
      lives = Math.max(0, lives - 1);
      px = Math.floor(W/2); 
      py = Math.floor(H/2);
      hitCooldown = HIT_IFRAME_MS;
      if (lives === 0) {
        running = false;
      }
    }
  }

  function showGameOver() {
    hitCooldown = 0;
    const best = saveBest(nick, score);
    const baseLines = [
      '',
      '===== GAME OVER =====',
      `최종 점수: ${score}   최고 점수(${nick}): ${best}`,
      ''
    ];

    if (!firebaseEnabled) {
      const localTop = getTopScores();
      if (localTop.length > 0) {
        baseLines.push('===== TOP 10 (Local) =====');
        localTop.forEach(([name, bestScore], idx) => {
          baseLines.push(`${idx + 1}. ${name}: ${bestScore}`);
        });
        baseLines.push('');
      }
      baseLines.push('R: 재시작, Q: 종료');
      draw(baseLines);
      return;
    }

    const pendingLines = [...baseLines, '온라인 리더보드 갱신 중...', '', 'R: 재시작, Q: 종료'];
    draw(pendingLines);

    submitOnlineScore(nick, score)
      .catch((err) => {
        console.warn('Leaderboard submit failed:', err);
        throw err;
      })
      .then(() => fetchOnlineLeaderboard(10))
      .then((entries) => {
        const lines = [...baseLines];
        if (entries.length > 0) {
          lines.push('===== ONLINE TOP 10 =====');
          entries.forEach((entry, idx) => {
            const lineName = typeof entry.name === 'string' ? entry.name : 'Player';
            lines.push(`${idx + 1}. ${lineName}: ${entry.score}`);
          });
          lines.push('');
        } else {
          lines.push('온라인 리더보드 데이터가 없습니다.');
          lines.push('');
        }
        lines.push('R: 재시작, Q: 종료');
        draw(lines);
      })
      .catch((err) => {
        const message = err && err.message ? String(err.message) : '네트워크 오류';
        const errorLines = [...baseLines, '온라인 리더보드 갱신 실패', message, '', 'R: 재시작, Q: 종료'];
        draw(errorLines);
      });
  }

  // ====== 메인 루프 ======
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;
    let acc = (window.gameAcc || 0) + dt;

    hitCooldown = Math.max(0, hitCooldown - dt);

    if (!running || lives <= 0) {
      showGameOver();
      return;
    }
    while (acc >= TICK_MS && running && lives > 0) {
      moveEnemies();
      collide();
      if (score >= 100 && score > lastEnemySpawnScore && (score - lastEnemySpawnScore) % 100 === 0 && rnd(1,100) <= 25) {
        enemies.push([rnd(1,W-2), rnd(1,H-2)]);
        lastEnemySpawnScore = score;
      }
      acc -= TICK_MS;
    }

    window.gameAcc = acc;
    draw();
    gameLoopId = requestAnimationFrame(loop);
  }

  // ====== 입력 ======
  window.addEventListener('keydown', (e) => {
    const c = e.code;
    if (c === 'KeyQ') { 
      running = false; 
      return; 
    }
    if (c === 'KeyR') { 
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      resetGame();
      window.gameAcc = 0;
      last = performance.now();
      draw();
      gameLoopId = requestAnimationFrame(loop);
      return; 
    }
    if (!running || lives <= 0) return;

    if (c === 'KeyW' || c === 'ArrowUp')    movePlayerBy(0,-1);
    else if (c === 'KeyS' || c === 'ArrowDown') movePlayerBy(0, 1);
    else if (c === 'KeyA' || c === 'ArrowLeft') movePlayerBy(-1,0);
    else if (c === 'KeyD' || c === 'ArrowRight')movePlayerBy( 1,0);
  });

  screen.addEventListener('click', () => screen.focus());
  screen.focus();

  // ====== 시작 ======
  resetGame();
  window.gameAcc = 0;
  draw();
  gameLoopId = requestAnimationFrame(loop);
})();
</script>